### 1. 객체 지향 프로그래밍(Object-Oriented Programming)이란?

> ==어떤 데이터를 입력받아 순서대로 처리하고 결과를 도출하는 명령어들의 목록==으로 보는 시각에서 벗어나 ==여러 독립적인 부품들의 조합, 즉 객체들의 유기적인 협력과 결합으로 파악==하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미

#### 객체 지향 프로그래밍의 장점
> 프로그램을 유연하고 변경이 용이하게 만들 수 있다.
> 코드의 재사용성이 높고 유지보수가 용이하며, 중복된 코드의 제거가 가능하다.
> 접근제어자와 메서드를 통해 데이터를 보호하고 올바른 값을 유지할 수 있다.

#### 객체 지향 4대 특징

##### 추상화
> 비슷한 역할을 하는 상태와 행동을 묶어 하나의 모델로 만들어 내는 것.
> ==공통성과 본질을 모아 추출하는 모델링==을 의미한다.

![](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B0%9D%EC%B2%B41.png?raw=true)

> 추상화는 역할과 구현의 분리이다.

##### 상속
> 부모 클래스의 메소드, 변수 등의 특징을 자식 클래스가 물려받는 것을 의미한다.
> 이를 통해 반복적인 코드를 최소화 할 수 있다.

##### 다형성
> 어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질을 의미한다.
> 같은 이름의 메소드가 클래스 별로 다른 행위를 하거나(Override), 클래스 내에서 같은 이름의 메서드를 여러개 중복하여 정의(Overloading)하여 사용할 수 있다.

![](https://github.com/idkim97/idkim97.github.io/blob/master/img/%EA%B0%9D%EC%B2%B42.png?raw=true)

##### 캡슐화
> 외부로부터 클래스에 정의된 속성과 기능을 보호하고, 필요한 부분만 외부로 노출 될 수 있도록 하여 각 ==객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적== 이다.
> 캡슐화는 접근제어자를 활용하여 클래스나 맴버들을 외부에서 접근하지 못하도록 제한하여 관리한다. 
> 응집도(클래스 내부의 변수와 메서드 간의 의존 정도)를 높게, 결합도(클래스들 간의 의존되어 있는 정도)를 낮게 하여 설계한다.

### 2. 객체 지향 프로그래밍의 5가지 설계 원칙

> SOLID 란 객체 지향 프로그래밍을 개발하면서 지켜야하는 5대 원칙으로 각각 SRP(단일 책임 원칙), OCP(개발-폐쇄 원칙), LSP(리스코프 치환 원칙), DIP(의존 역전 원칙), ISP(인터페이스 분리 원칙)의 앞글자를 따서 만들어졌다.

#### - 단일 책임 원칙(Single Responsibility Principle, SRP)

> 모듈이 변경되는 이유는 한가지여야 한다. 해당 모듈이 여러 대상(사용자 등록, 패스워드 암호화) 또는 액터들에 대해 책임을 가져서는 안되고, 오직 하나의 액터에 대해서만 책임을 져야 한다.
> 만약 어떤 모듈이 여러 액터에 대해 책임을 가지고 있다면 여러 액터들로부터 변경에 대한 요구가 올 경우 해당 모듈을 수정해야 하는 이유 역시 여러 개가 될 수 있다. 반면 하나의 책임만을 가진 모듈이 있다면 해당 모듈을 변경해야 하는 이유가 명확하다. 여기서 모듈은 클래스 혹은 클래스의 모음 등으로 해석할 수 있다.

> 만약 사용자 추가 로직에 사용자 등록, 패스워드 암호화가 있을 경우 패스워드 암호화에 대한 변경 요청이 발생할 경우 사용자 등록에 대한 메소드를 변경해야 하기에 이럴 경우 단일 책임 원칙에 위배된다. 그렇기에 패스워드 암호화를 추상화 시키고 해당 클래스를 합성하여 사용한다면 책임을 분리할 수 있다.

> 단일 책임 원칙을 적용하여 적절하게 책임과 관심을 분리하여, 서로 영향을 주지 않도록 추상화함으로 애플리케이션의 변화에 대응할 수 있다.

#### - 개방 폐쇄 원칙(Open-Closed Principle, OPC)

> 확장에는 열려있고 수정에는 닫혀있어야 하는 것이 개방 폐쇄 원칙이다.
> - 확장에 대해 열려 있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
> - 수정에 대해 닫혀 있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.
> 사용자의 패스워드 암호화 방식이 변경될 경우 개발 폐쇄 원칙에 따라 기존 로직은 수정되면 안된다. 이럴 때 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다. 추상화는 책심적인 부분을 남기고 불필요한 부분을 제거함으로써 복잡한 것을 간단히 하는 것이고, 추상화를 통해 변하지 않는 부분만 남겨 기능을 구체화하고 확장할 수 있다. 
> 이에 패스워드 암호화 부분을 추상화하고, 사용자 등록은 추상화된 패스워드 암호화를 사용하고 구체적인 암호화 정책은 해당 추상화된 Interface를 상속하여 구현한다.

> 개방 폐쇄 원칙은 추상화를 본질적으로 사용하라는 이야기이고, 이는 결국 런타임 의존성과 컴파일 타임 의존성에 대한 이야기이다. 다형성을 지원하는 객체 지향 프로그래밍에서 런타임 의존성과 컴파일타임 의존성은 동일하지 않다. 컴파일 시점에 사용자는 패스워드 암호화 추상화된 객체에 의존하고 있지만 런타임 시에는 구체 클래스(암호화 정책)에 의존하는 것이다.

#### - 인터페이스 분리 원칙(Interface segregation principle, ISP)

> 객체가 충분히 높은 응집도의 작은 단위로 설계되었더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리해줄 필요가 있는데, 이를 인터페이스 분리 원칙이라고 부른다. 인터페이스 분리 원칙은 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이다. 
> 인터페이스 분리 원칙을 준수함으로 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스 만을 접근하여 불필요한 간섭을 최소화 할 수 있으며, 기존 클라이언트에 영향을 주지 않은 채고 유연하게 객체의 기능을 확장하거나 수정 할 수 있다.

> 인증 서비스에서 패스워드 암호화를 통해 패스워드가 일치하는지 확인해야 하는 기능을 구현한다면 인증 서비스에서 필요한 부분은 해당 패스워드가 일치하는지 확인하는 기능만을 필요로 한다. 그렇기에 기존 패스워드 암호화에 해당 기능을 추가하는 것이 아닌 별도의 패스워드 확인 인터페이스를 추가하여 주입받아 사용하는 방식으로 한다면 목적과 용도에 맞는 인터페이스를 구분할 수 있다.

#### - 리스코프 치환 법칙(Liskov Substituation Principle, LSP)

> 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것이다. 해당 객체를 사용하는 클라이언트가 상위 타입이 하위 타입으로 변경되어도, 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것이다.
> 클라이언트와 객체 사이의 계약이 존재하고, 이를 준수해야 한다는 원칙이다. 하위 클래스는 상위 클래스의 동작 규칙을 따라야 하는 것이다.

> 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것이다. 

-  상위 클래스가 주문 정렬을 위한 sortOrdersByAmount() 함수를 구현해두었는데, 하위 클래스에서 생성 날짜에 따라 정렬되도록 변경한 경우
    
- 하위 클래스가 입력, 출력 및 예외에 대한 상위 클래스의 계약을 위반하는 경우
    
    - 상위 클래스에서 오류가 발생하면 null을, 값을 얻을 수 없으면 빈 컬렉션을 반환하게 해두었는데, 하위 클래스에서 오류가 발생하면 예외를 발생시키고, 값을 얻을 수 없을 때 null을 반환하도록 변경한 경우
    - 상위 클래스에서는 입력 시 모든 정수를 허용하지만, 하위 클래스에서는 음수일 때 예외를 발생시키는 경우
    - 상위 클래스에서 던지는 예외는 ArgumentException 뿐인데, 하위 클래스에서 다른 예외도 던지는 경우
    
- 하위 클래스가 상위 클래스의 주석에 나열된 특별 지침을 위반하는 경우
    
    - 상위 클래스에 예금을 인출하는 withdraw() 메서드에 사용자의 출금 금액이 잔액을 초과해서는 안된다는 주석이 있을 때, 하위 클래스에서는 가능한 경우

#### - 의존 역전 원칙(Dependency Inversion Principle, DIP)

> 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙이다.  
> 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것이다.

> 의존 역전 원칙이란 결국 비지니스와 관련된 부분이 세부 사항에는 의존하지 않는 설계 원칙을 의미한다.

![](https://blog.kakaocdn.net/dn/cgWOqH/btrjHUA2RyR/AvHKl9eXnkvppp8EPHdyrk/img.png)

> 의존 역전 원칙에서 의존성이 역전되는 시점은 컴파일 시점이다. 런타임 시점에는 구체 클래스에 의존하게 된다. 이런 부분을 의존 역전 원칙이라고 한다. 


참고 URL : https://mangkyu.tistory.com/194

