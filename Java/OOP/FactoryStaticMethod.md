
### 정적 팩토리 메서드란?

쉽게 말해 생성자로 객체를 생성하지 않고, static 메소드를 사용해 객체를 생성하는 방식이다.


### 왜 정적 팩토리 메서드를 사용하는가?

#### 1. 이름을 가질 수 있다.

클래스의 내부 구조를 모르는 사람은 객체를 생성할 떄 어떤 인자가 들어가야 하는지 모른다.
정적 팩토리 메서드를 이용하면 ==어떤 객체를 생성할지 메서드의 이름으로 구별하여 가독성이 좋아진다==.

#### 2. 호출할 때 마다 인스턴스를 새로 생성하지 않아도 된다.(싱글톤 활용 가능)

```java
public class Game {
    private static final Game instance = new Game();
    private Game() {}
    public static Game getInstance() {
        return instance;
    }
}
```

위 처럼 ==싱글톤으로 객체를 하나만 만들어두고 이를 재사용하여 불필요한 객체 생성을 막을 수 있다==.
오로지 하나의 객체만 반환하기에 메모리를 절약할 수 있다는 장점이 있다.
하지만 싱글톤은 한번만 생성되어 상태를 공유되어야 하는 경우에 유용하게 사용할 수 있지만, 객체가 다른 상태를 가져야 하는 경우 위 방식은 사용하면 안된다.

#### 3. 반환 타입의 하위 타입 객체를 반환할 수 있다.

```
List<String> unmodifiableList = Collections.unmodifiableList(modifiableList);
```

unmodifiableList()를 메서드에서 반환하는 ==UnmodifiableList<> 타입은 List<> 인터페이스의 구현체==이다.
unmodifiableList()를 호출하는 반환 타입이 List<> 인터페이스를 구현한 구현체가 아니었다면
우리는 UnmodifiableList<>의 실제 구현에 대해 알 필요가 있었을 것이다.
 즉, UnmodifiableList<> 객체를 생성하고 사용하기 위해 해당 클래스의 생성자와 메서드에 대해 직접적으로 알아야하는 것이다.
하지만 정적 팩토리 메서드인 Collections.unmodifiableList() 덕분에, 우리는 단순히 이 메서드를 호출하기만 하면 된다.
 이 메서드가 내부적으로 어떻게 동작하는지, 어떤 클래스의 인스턴스를 반환하는지 등은 크게 중요하지 않다.
중요한 것은 그 반환값이 List<> 인터페이스를 구현하는 구현체라는 것이다.
따라서, **UnmodifiableList<>이라는 구현체가 어떤 구현체인지 알지 못해도 사용할 수 있는것**이다.
또한, unmodifiableList() 메서드 내부 구현이 바뀌더라도, 우리 코드는 영향을 받지 않는다.
즉, **단순하게 사용할 수 있고, 유연성을 높일 수 있다.**

#### 4. 파라미터에 따른 다른 객체를 반환할 수 있다.

파라미터에 따라 분기 처리하여 다른 객체를 반환 하도록 할 수 있다.
해당 인터페이스를 구현하는 구현체 클래스들을 파라미터 별로 반환할 수 있는 것이다.
이로 인해 유연한 확장성과 내부를 드러내지 않아 캡슐화를 할 수 있다는 장점이 있다.


### 정적 팩토리 메서드의 문제점

#### 1. 상속 불가능

생성자로 인스턴스를 생성하는 것을 막기 위해 생성자 접근 제어자를 private으로 설정한다. 그렇기에 해당 생성자에 접근할 수가 없어 상속이 불가능하다는 문제가 생긴다. 
하지만 상속 보단 합성 원칙을 보면 상속에 대해 단점과 한계를 많이 설명하고 있고, 상속보다는 합성을 사용하는 것을 권한다.

> **생성자 방식 (상속이 안되지만 예시를 위해 추가)**

```java
public class Car {
	private Car() {}
	public static Car createCar() {
		return new Car();
	}
}
public class SportsCar extends Car { }
```

> **상속 대신 합성 사용**

```java
public class Car {
	private Car() {    }
	public static Car createCar() {
		return new Car();
	}
}
public class SportsCar {
	private final Car car;
	public SportsCar(Car car) {
		this.car = car;
	}
}
```

위 코드는 **SportsCar 객체가 더 이상 Car를 상속 받지 않고, Car를 인스턴스 변수**로 갖고 있다.

이런식으로 **합성을 사용하면 직접적으로 Car의 생성자를 호출할 필요가 없기 때문에 이 단점이 해결**된다.

또한 **상속을 사용했을 때보다 결합도가 낮아지고 유연성이 증가**하게 된다.

#### 2. 정적 팩토리 메서드를 다른 개발자들이 찾기 어렵다.

Javadoc 문서를 봤을 때 생성자는 바로 확인이 가능하지만 정적 팩토리 메서드는 해당 객체를 반환하는 별도의 메서드를 찾아야한다. 그렇기 때문에 가독성 적인 측면으로는 편하지 않다. 하지만 API 문서를 깔끔하게 작성하거나, 네이밍 규칙을 지키면 해당 단점을 극복할 수 있다.


### 정적 팩토리 메서드는 언제 사용하면 좋을까?

1. 생성자에 넘길 매개변수가 많을 때
	: 매개 변수가 많을 경우 생성자에서는 어떤 매개변수가 어떤 값을 의미하는지 알기 어렵다.
	: 반면, 메서드 이름을 통해 의도를 명확히 표현할 때 사용할 수 있다.
2. 명시적 객체 생성이 불필요할 때
	: 불필요한 객체를 여러번 생성할 필요가 없을 때 싱글턴 객체를 반환할 수 있다. 이로 인해 캐시하여 재사용하는 방식으로 리소스를 효율적으로 사용할 수 있게 된다.
3. 입력 파라미터에 따라 매번 다른 클래스의 객체를 반환할 필요가 있을 때
4. 초기화에 복잡한 로직이 필요할 때
5. 유연한 확장성이 필요할 때
	: 프레임워크나 라이브러리를 만들 때 특히 유용하다.
	: 정적 팩토리 메서드를 작성하는 시점에 반환할 객체가 존재하지 않아도 된다. 실제 메서드를 호출하는 시점에 결정되는 것이며, 개발자는 메서드를 호출하기만 하면 되고, 데이터 베이스에 대한 구체적인 지식없이도 데이터베이스 접근이 가능해 진다.



출처: [https://hstory0208.tistory.com/entry/OOP-정적-팩토리-메서드를-왜-사용하는가-어떤-상황에-사용하는게-좋을까-생성자와-차이](https://hstory0208.tistory.com/entry/OOP-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%8C-%EC%A2%8B%EC%9D%84%EA%B9%8C-%EC%83%9D%EC%84%B1%EC%9E%90%EC%99%80-%EC%B0%A8%EC%9D%B4) [< Hyun / Log >:티스토리]


